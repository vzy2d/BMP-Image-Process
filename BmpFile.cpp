#include "BmpFile.h"  using namespace std;  BmpFile::BmpFile() { 	fileName_IN = "NULL"; 	rgbQuad = NULL; 	R = NULL; 	G = NULL; 	B = NULL; 	bitmap_gray = NULL; 	bitmap_color = NULL; 	//imArray_temp = NULL;	//存放位图数据 	//myFileHeader = {0};	//这么做似乎会引起内存操作越界问题 	//myBitMapHeader = {0}; 	sizeofrgbQuad = 0; }  BmpFile::~BmpFile() { 	delete R; 	delete G; 	delete B; 	delete rgbQuad; 	delete bitmap_gray; 	delete bitmap_color; 	if (isGrayImg()) { 		for (int i = 0; i < myBitMapHeader.height; i++) 		{ 			delete[] bitmap_gray[i]; 		} 		delete[] bitmap_gray; 	} 	if (isColorImg()) { 		for (int i = 0; i < 3; i++) 		{ 			for (int j = 0; j < myBitMapHeader.height; j++) 			{ 				delete[] bitmap_color[i][j]; 			} 			delete[] bitmap_color[i]; 		} 		delete[] bitmap_color; 	} }  bool BmpFile::isGrayImg() { 	return (myBitMapHeader.bitsperpixel == 8) ? 1 : 0; }  bool BmpFile::isColorImg() { 	return (myBitMapHeader.bitsperpixel == 24) ? 1 : 0; }  void BmpFile::printImgInfo() { 	cout << "Img Info of <" << fileName_IN << ">" << endl; 	cout << "File Type:" << myFileHeader.filetype[0] << myFileHeader.filetype[1] << endl; 	cout << "File Type:" << myFileHeader.filesize << endl; 	cout << "Height of Img:" << myBitMapHeader.height << endl; 	cout << "Width of Img:" << myBitMapHeader.width << endl; }  void BmpFile::load(string file_path) { 	this->~BmpFile(); 	fileName_IN = file_path; 	ifstream infile(file_path, ios::in | ios::binary); 	if (!infile) { 		std::cout << "Open file failed." << std::endl; 		exit(OPEN_FILE_ERROR); 	} 	// File Header 	infile.seekg(0, ios::beg); 	infile.read((char*)&(myFileHeader.filetype), 2 * sizeof(char));  	infile.seekg(2, ios::beg); 	infile.read((char*)&(myFileHeader.filesize), sizeof(int));  	infile.read((char*)&(myFileHeader.reserved1), sizeof(short)); 	infile.read((char*)&(myFileHeader.reserved2), sizeof(short));  	infile.seekg(10, ios::beg); 	infile.read((char*)&(myFileHeader.bitmapoffset), sizeof(int));  	// Info Header 	infile.seekg(14, ios::beg); 	infile.read((char*)&(myBitMapHeader.sizeofinfoheader), sizeof(int));  	infile.seekg(18, ios::beg); 	infile.read((char*)&(myBitMapHeader.width), sizeof(int)); 	infile.read((char*)&(myBitMapHeader.height), sizeof(int));  	infile.read((char*)&(myBitMapHeader.planes), sizeof(short));  	infile.read((char*)&(myBitMapHeader.bitsperpixel), sizeof(short));  	infile.read((char*)&(myBitMapHeader.compression), sizeof(int));  	infile.seekg(34, ios::beg); 	infile.read((char*)&(myBitMapHeader.sizeofbitmap), sizeof(int));  	infile.read((char*)&(myBitMapHeader.horzres), sizeof(int));  	infile.read((char*)&(myBitMapHeader.vertres), sizeof(int));  	// rgbQuad 	sizeofrgbQuad = myFileHeader.bitmapoffset - myBitMapHeader.sizeofinfoheader - 14; 	if (isGrayImg()) { 		rgbQuad = new uint8_t[sizeofrgbQuad]; 		infile.seekg(myBitMapHeader.sizeofinfoheader + 14, ios::beg); 		infile.read((char*)rgbQuad, sizeofrgbQuad); 	}  	// bitmap 	uint8_t temp[3];  	if (isGrayImg()) { 		bitmap_gray = new uint8_t* [myBitMapHeader.height]; 		for (int i = 0; i < myBitMapHeader.height; i++) 		{ 			bitmap_gray[i] = new uint8_t[myBitMapHeader.width]; 		} 		infile.seekg(myFileHeader.bitmapoffset, ios::beg); 		for (int y = 0; y < myBitMapHeader.height; y++) { 			for (int x = 0; x < myBitMapHeader.width; x++) { 				infile.read((char*)temp, 1); 				bitmap_gray[x][y] = temp[0]; 			} 		} 	} 	if (isColorImg()) { 		bitmap_color = new uint8_t ** [3]; 		for (int i = 0; i < 3; i++) 		{ 			bitmap_color[i] = new uint8_t * [myBitMapHeader.height]; 			for (int j = 0; j < myBitMapHeader.height; j++) 			{ 				bitmap_color[i][j] = new uint8_t[myBitMapHeader.width]; 			} 		} 		infile.seekg(myFileHeader.bitmapoffset, ios::beg); 		for (int y = 0; y < myBitMapHeader.height; y++) { 			for (int x = 0; x < myBitMapHeader.width; x++) { 				infile.read((char*)temp, 3); 				bitmap_color[R_chn][x][y] = temp[R_chn]; 				bitmap_color[G_chn][x][y] = temp[G_chn]; 				bitmap_color[B_chn][x][y] = temp[B_chn]; 			} 		} 	}  	infile.close(); }  void BmpFile::load(const char* file_path) { 	string file_p(file_path); 	this->load(file_p); }  void BmpFile::save(string file_path) { 	char header[54] = { 	  0x42,        // identity : B 	  0x4d,        // identity : M 	  0, 0, 0, 0,  // file size 	  0, 0,        // reserved1 	  0, 0,        // reserved2 	  54, 0, 0, 0, // RGB data offset 	  40, 0, 0, 0, // struct BITMAPINFOHEADER size 	  0, 0, 0, 0,  // bmp width 	  0, 0, 0, 0,  // bmp height 	  1, 0,        // planes 	  24, 0,       // bit per pixel 	  0, 0, 0, 0,  // compression 	  0, 0, 0, 0,  // data size 	  0, 0, 0, 0,  // h resolution 	  0, 0, 0, 0,  // v resolution  	  0, 0, 0, 0,  // used colors 	  0, 0, 0, 0   // important colors 	};  	ofstream outfile(file_path, ios::out | ios::binary);  	if (!outfile) { 		cout << " Write image error!!" << endl; 		exit(SAVE_FILE_ERROR); 	}  	uint64_t filesize = myFileHeader.filesize; 	 if (isGrayImg()) { 		 filesize = myBitMapHeader.width * myBitMapHeader.height + myFileHeader.bitmapoffset; 	 }else { 		 filesize = myBitMapHeader.width * myBitMapHeader.height + myFileHeader.bitmapoffset; 	 } 	 header[2] = (uint8_t)(myFileHeader.filesize & 0x000000ff); 	 header[3] = (myFileHeader.filesize >> 8)  & 0x000000ff; 	 header[4] = (myFileHeader.filesize >> 16) & 0x000000ff; 	 header[5] = (myFileHeader.filesize >> 24) & 0x000000ff;  	 // width 	 header[18] = myBitMapHeader.width & 0x000000ff; 	 header[19] = (myBitMapHeader.width >> 8)  & 0x000000ff; 	 header[20] = (myBitMapHeader.width >> 16) & 0x000000ff; 	 header[21] = (myBitMapHeader.width >> 24) & 0x000000ff;  	 // height 	 header[22] = myBitMapHeader.height &0x000000ff; 	 header[23] = (myBitMapHeader.height >> 8)  & 0x000000ff; 	 header[24] = (myBitMapHeader.height >> 16) & 0x000000ff; 	 header[25] = (myBitMapHeader.height >> 24) & 0x000000ff;  	 header[34] = myBitMapHeader.sizeofbitmap &0x000000ff; 	 header[35] = (myBitMapHeader.sizeofbitmap >> 8)  & 0x000000ff; 	 header[36] = (myBitMapHeader.sizeofbitmap >> 16) & 0x000000ff; 	 header[37] = (myBitMapHeader.sizeofbitmap >> 24) & 0x000000ff;  	 // write header 	 outfile.write(header,54);  	 //// write image 	 //if(new_color_data != NULL){ 	 //	outfile.write((char*)new_color_data,sizeof(char)* row_size * height); 	 //} 	 //else{ 	 //	outfile.write((char*)color_data,sizeof(char)* row_size * height); 	 //} 	 outfile.close(); }   void BmpFile::save(const char* file_path) { 	string file_p(file_path); 	this->save(file_p); }  uint8_t BmpFile::ImArray(uint32_t row, uint32_t col) { 	return uint8_t(0);// this->bitmap_gray[row * this->myBitMapHeader.width + col]); }  void BmpFile::ImArray(uint32_t row, uint32_t col, uint16_t dat_in) { 	//this->bitmap_gray[row * this->myBitMapHeader.width + col] = dat_in; }  uint8_t BmpFile::ImArray(uint32_t row, uint32_t col, uint8_t chn) { 	switch (chn) 	{ 	case R_chn: 		return uint8_t(this->R[row * myBitMapHeader.width + col]); 	case G_chn: 		return uint8_t(this->G[row * myBitMapHeader.width + col]); 	case B_chn: 		return uint8_t(this->B[row * myBitMapHeader.width + col]); 	default: 		break; 	} }  void BmpFile::ImArray(uint32_t row, uint32_t col, uint8_t chn, uint16_t dat_in) { 	switch (chn) 	{ 	case R_chn: 		this->R[row * myBitMapHeader.width + col] = dat_in; 	case G_chn: 		this->G[row * myBitMapHeader.width + col] = dat_in; 	case B_chn: 		this->B[row * myBitMapHeader.width + col] = dat_in; 	default: 		break; 	} } 